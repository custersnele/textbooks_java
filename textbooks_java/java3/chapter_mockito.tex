\chapter{Mockito}

\fcolorbox{black}[HTML]{E9F0E9}{\parbox{\textwidth}{%
\noindent \textbf{Learning goals}\\
The junior-colleague
\begin{enumerate}[nolistsep]
\item can describe the usage of mockito.
\item can implement unit tests with mockito.
\end{enumerate}}}

\section{Mocking with Mockito}

\fcolorbox{black}[HTML]{ADD8E6}{\parbox{\textwidth}{%
\noindent \textbf{Source for this section:}\\
mocking\_example: \url{https://github.com/PXLJavaAdvanced2/mocking_example.git}
}}

While writing unit tests,  you spend quite some time creating the initial test data. Using the builder pattern makes your test code more readable and maintainable.

Located in the test-folder, you will find the SuperheroBuilder in the package be.pxl.superhero.builder.
There are plugins for IntelliJ IDEA that generate builder-classes (e.g.  Generate Builder plugin).

\begin{lstlisting}[frame=single,language=java]
package be.pxl.superhero.builder;

import be.pxl.superhero.domain.Superhero;

public final class SuperheroBuilder {

	private String firstName;
	private String lastName;
	private String superheroName;
	private String phoneNumber;

	private SuperheroBuilder() {}

	public static SuperheroBuilder aSuperhero() {return new SuperheroBuilder();}

	public SuperheroBuilder withFirstName(String firstName) {
		this.firstName = firstName;
		return this;
	}

	public SuperheroBuilder withLastName(String lastName) {
		this.lastName = lastName;
		return this;
	}

	public SuperheroBuilder withSuperheroName(String superheroName) {
		this.superheroName = superheroName;
		return this;
	}

	public SuperheroBuilder withPhoneNumber(String phoneNumber) {
		this.phoneNumber = phoneNumber;
		return this;
	}

	public Superhero build() {
		Superhero superhero = new Superhero(firstName, lastName, superheroName);
		superhero.setPhoneNumber(phoneNumber);
		return superhero;
	}
}
\end{lstlisting}

\begin{oefening}
Change the property ironman.phonenumber in the file application.properties to your own phone number.
Run the main-class CallIronManApp. Investigate the source code and debug if necessary to learn to understand the program.
The SmsService uses Textbelt to send an SMS.  Using the API key textbelt one test SMS per day is allowed.
\end{oefening}

Next, we want to test the methods in the class CallService.  The CallService uses the SMSService, but while executing the unit tests, we don't want to use the actual SMSService. The solution here is mocking. 
To create tests with Mockito, we add the annotation @ExtendWith(MockitoExtension.class) to the test class.
We mock the SMSService and inject the mock in the CallService under test. The mock is a dummy for the SMSService.
The test smsServiceIsUsedOnCall verifies that the dummy SMSService is called with the correct arguments.


\begin{lstlisting}[frame=single, language=java]
package be.pxl.superhero.mocking;

import be.pxl.superhero.CallService;
import be.pxl.superhero.SmsService;
import be.pxl.superhero.builder.SuperheroBuilder;
import be.pxl.superhero.domain.Superhero;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;

@ExtendWith(MockitoExtension.class)
public class CallServiceTest {

	@Mock
	private SmsService smsService;

	@InjectMocks
	private CallService callService;

	private final Superhero hero1 = SuperheroBuilder.aSuperhero().withSuperheroName("Hero 1").withPhoneNumber("123456").build();

	@Test
	public void smsServiceIsUsedOnCall() {
		callService.call(hero1, "TestMessage");
		Mockito.verify(smsService).sendSms( "TestMessage", "123456");
	}
}
\end{lstlisting}

\begin{oefening}
Implement the CallServiceTest-class.  Add extra unit tests to test all methods and functionality of the CallService-class.
\end{oefening}


\section{Testing SupheroService}

\fcolorbox{black}[HTML]{ADD8E6}{\parbox{\textwidth}{%
\noindent \textbf{Source for this section:}\\
superhero-backend
}}

We started with a simple example.  However, in practice we use Mockito when we test the Service-layer of our application. In this section we discuss more complex unit tests with Mockito.

The name of a superhero must be unique. To accomplish this, we add the unique constraint to our database column. 
However, it is good practice to implement this business rule in the service layer.
Database constraints are the last line of defence, not the only. 

\begin{lstlisting}[frame=single,language=java]
package be.pxl.superhero.domain;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name="superheroes")
public class Superhero {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	private String firstName;
	private String lastName;
	@Column(unique = true)
	private String superheroName;

	public Superhero() {
		// JPA only
	}

	public Superhero(String firstName, String lastName, String superheroName) {
		this.firstName = firstName;
		this.lastName = lastName;
		this.superheroName = superheroName;
	}

	public Long getId() {
		return id;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public String getSuperheroName() {
		return superheroName;
	}

	public void setSuperheroName(String superheroName) {
		this.superheroName = superheroName;
	}
}
\end{lstlisting}



\begin{lstlisting}[frame=single, language=java]
package be.pxl.superhero.service.impl;

import be.pxl.superhero.api.SuperheroDTO;
import be.pxl.superhero.api.SuperheroRequest;
import be.pxl.superhero.domain.Superhero;
import be.pxl.superhero.exception.ResourceNotFoundException;
import be.pxl.superhero.repository.SuperheroRepository;
import be.pxl.superhero.service.SuperheroService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.validation.ValidationException;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class SuperheroServiceImpl implements SuperheroService {

	private final SuperheroRepository superheroRepository;

	@Autowired
	public SuperheroServiceImpl(SuperheroRepository superheroRepository) {
		this.superheroRepository = superheroRepository;
	}

	public SuperheroDTO createSuperhero(SuperheroRequest superheroRequest) {
		Optional<Superhero> existingSuperhero = superheroRepository.findSuperheroBySuperheroName(superheroRequest.getSuperheroName());
		existingSuperhero.ifPresent(s -> {
			throw new ValidationException("This superhero name is already taken.");
		});
		Superhero superhero = new Superhero();
		superhero.setFirstName(superheroRequest.getFirstName());
		superhero.setLastName(superheroRequest.getLastName());
		superhero.setSuperheroName(superheroRequest.getSuperheroName());
		Superhero newSuperhero = superheroRepository.save(superhero);
		return new SuperheroDTO(newSuperhero);
	}
	
	// other methods intenionally left out

}
\end{lstlisting}


Now we need unit tests for the method \textit{createSuperhero}. There's one problem, we need a SuperheroRepository to thoroughly test the method.  The solution is mocking the database layer. Here,  mocking means create a dummy layer and no actual operation will happen during database save or fetch. 

In Mockito we can mock methods in 2 different ways:

\begin{itemize}
\item Using when-then syntax e.g.: when(..).thenReturn() or when(..).thenAnswer(â€¦)
\item Using do-when syntax e.g.: doReturn(..).when()
\end{itemize}

For mocked objects it is best practice to use when-then option as it provides return type checking and it is more readable.

For mocking void methods, there is no when-then option. We have to use do-when syntax.

 
 \begin{lstlisting}[frame=single, language=java]
package be.pxl.superhero.service.impl;

import be.pxl.superhero.api.SuperheroDTO;
import be.pxl.superhero.api.SuperheroRequest;
import be.pxl.superhero.builder.SuperheroBuilder;
import be.pxl.superhero.domain.Superhero;
import be.pxl.superhero.repository.SuperheroRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.AdditionalAnswers;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.validation.ValidationException;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.InstanceOfAssertFactories.LONG_STREAM;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class SuperheroServiceImplTest {

	private static final String SUPERHERO_NAME = "Superman";
	private static final String FIRST_NAME = "Clark";
	private static final String LAST_NAME = "Kent";

	@Mock
	private SuperheroRepository superheroRepository;

	@Captor
	private ArgumentCaptor<Superhero> superheroCaptor;

	@InjectMocks
	private SuperheroServiceImpl superheroService;

	private final Superhero superhero = SuperheroBuilder.aSuperhero()
			.withFirstName(FIRST_NAME)
			.withLastName(LAST_NAME)
			.withSuperheroName(SUPERHERO_NAME)
			.build();

	@Test
	public void throwsValidationExceptionWhenSuperheroNameIsNotUnique() {
		when(superheroRepository.findSuperheroBySuperheroName(SUPERHERO_NAME)).thenReturn(Optional.of(superhero));
		SuperheroRequest request = new SuperheroRequest(FIRST_NAME, LAST_NAME, SUPERHERO_NAME);
		ValidationException validationException = assertThrows(ValidationException.class, () -> superheroService.createSuperhero(request));
		assertEquals("This superhero name is already taken.", validationException.getMessage());
	}

	@Test
	public void savesSuperheroWhenSuperheroNameIsUnique() {
		when(superheroRepository.findSuperheroBySuperheroName(SUPERHERO_NAME)).thenReturn(Optional.empty());
		when(superheroRepository.save(Mockito.any(Superhero.class))).thenAnswer(AdditionalAnswers.returnsFirstArg());
		SuperheroRequest request = new SuperheroRequest(FIRST_NAME, LAST_NAME, SUPERHERO_NAME);
		SuperheroDTO result = superheroService.createSuperhero(request);
		assertEquals(FIRST_NAME, result.getFirstName());
		assertEquals(LAST_NAME, result.getLastName());
		assertEquals(SUPERHERO_NAME, result.getSuperheroName());
		Mockito.verify(superheroRepository).save(superheroCaptor.capture());
		Superhero savedSuperhero = superheroCaptor.getValue();
		assertEquals(FIRST_NAME, savedSuperhero.getFirstName());
		assertEquals(LAST_NAME, savedSuperhero.getLastName());
		assertEquals(SUPERHERO_NAME, savedSuperhero.getSuperheroName());
	}

	@Test
	public void findAllSuperheroes() {
		Superhero hero1 = SuperheroBuilder.aSuperhero().withSuperheroName("Batman").build();
		Superhero hero2 = SuperheroBuilder.aSuperhero().withSuperheroName("Superman").build();
		when(superheroRepository.findAll()).thenReturn(Arrays.asList(hero1, hero2));
		List<SuperheroDTO> allSuperheroes = superheroService.findAllSuperheroes();
		assertThat(allSuperheroes.stream().map(SuperheroDTO::getSuperheroName).collect(Collectors.toList()))
				.hasSize(2)
				.containsExactly("Batman", "Superman");
	}

}
\end{lstlisting}

All test classes that use Mockito, are annotated with @ExtendWith(MockitoExtension.class).  We want to create a dummy SuperheroRepository, therefore we create it with the annotation @Mock.
This dummy SuperheroRepsitory should be used by the SuperheroService under test.  We use the annotation @InjectMocks to use all the dummy classes in the SuperheroService instance.

The test throwsValidationExceptionWhenSuperheroNameIsNotUnique is a test for the scenario where the superhero is already saved in the database. Our dummy SuperheroRepository will return this existing superhero when he is retrieved by his superheroName.
During the test we call the method createSuperhero with test data but we expect the method to throw a ValidationException.  If the exception is not thrown, the test will fail. Finally, the error message of the exception is verified.


The test savesSuperheroWhenSuperheroNameIsUnique is a test for the scenario where the superhero doesn't exist yet.
The dummy SuperheroRepository will return an empty Optional.  While executing the test, the save method of the SuperheroRepository is called.  The result of this save method is used for creating the SuperheroDTO that is returned by the SuperheroService under test.
The save-method cannot return null, it would cause our test to end with a NullPointerException. Therefore, we make our dummy SuperheroRepository return something useful. We verify the return value of the method under test (createSuperhero). We verify the save() method is called with the expected argument.  This is accomplished with an argument captor. 

The third test is a test for the method findAllSuperheroes.  We test that the results retrieved from the dummy SuperheroRepository are mapped correctly to SuperheroDTOs.  This test uses AssertJ for the assertions. This is a useful library for writing readable assertions. 
 
 \begin{oefening}
 Open the superhero-backend project.
Install the Generate Builder-plugin in IntelliJ IDEA. 
Create the SuperheroBuilder and place it in the test-folder in package be.pxl.superhero.builder.
Add the class SuperheroServiceTest to your project and run (and debug!) the tests. 
Create a new test class with the name SuperheroServiceUpdateSuperheroTest.
Write unit tests for the method updateSuperhero in the class SuperheroServiceTest. 
\end{oefening}
 
 
 
 
 
 
