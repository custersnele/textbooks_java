\chapter{Mockito}

\fcolorbox{black}[HTML]{E9F0E9}{\parbox{\textwidth}{%
\noindent \textbf{Learning goals}\\
The junior-colleague
\begin{enumerate}[nolistsep]
\item can describe the usage of mockito.
\item can implement unit tests with mockito.
\end{enumerate}}}

\section{Mocking with Mockito}

Mockito is a popular open source framework for mocking objects in software test.

\begin{lstlisting}
package be.pxl.superhero.service;

public class MyService {

    private final OtherService otherService;

    public MyService(OtherService otherService) {
        this.otherService = otherService;
    }

    public int doCalculation(int value) {
        return value * otherService.getValue();
    }
}
\end{lstlisting}

\begin{lstlisting}
package be.pxl.superhero.service;

public interface OtherService {

    int getValue();
}
\end{lstlisting}

When writing a unit test for the method doCalculation() we need an object of the class OtherService. We don't need an object of an actual implementation of the interface. We can just mock the OtherService-object and tell it what it should return when it's called.

\begin{lstlisting}
package be.pxl.superhero.service;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class MyServiceTest {

    @Mock
    private OtherService otherService;
    @InjectMocks
    private MyService myService;

    @Test
    public void doCalculationTest() {
        when(otherService.getValue()).thenReturn(5);
        assertEquals(500, myService.doCalculation(100));
    }
}
\end{lstlisting}

\section{Unit testing the service-layer methods}


We use Mockito when we test the Service-layer of an application. In this section we discuss more complex unit tests with Mockito.

The name of a superhero must be unique. To accomplish this, we add the unique constraint to our database column. 
However, it is good practice to implement this business rule in the service layer.
Database constraints are the last line of defence, not the only. 


\begin{lstlisting}[frame=single, language=java]
package be.pxl.superhero.service.impl;

import be.pxl.superhero.api.MissionDTO;
import be.pxl.superhero.api.SuperheroDTO;
import be.pxl.superhero.api.SuperheroDetailDTO;
import be.pxl.superhero.api.SuperheroRequest;
import be.pxl.superhero.domain.Mission;
import be.pxl.superhero.domain.Superhero;
import be.pxl.superhero.exception.ResourceNotFoundException;
import be.pxl.superhero.repository.MissionRepository;
import be.pxl.superhero.repository.SuperheroRepository;
import be.pxl.superhero.service.SuperheroService;
import jakarta.validation.ValidationException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
public class SuperheroServiceImpl implements SuperheroService {

    private final SuperheroRepository superheroRepository;
    private final MissionRepository missionRepository;

    public SuperheroServiceImpl(SuperheroRepository superheroRepository,
                                MissionRepository missionRepository) {
        this.superheroRepository = superheroRepository;
        this.missionRepository = missionRepository;
    }

    public Long createSuperhero(SuperheroRequest superheroRequest) {
        Optional<Superhero> existingSuperhero = 
            superheroRepository.findSuperheroBySuperheroName(superheroRequest.getSuperheroName());
        existingSuperhero.ifPresent(s -> {
            throw new ValidationException("This superhero name is already taken.");
        });
            
        Superhero superhero = new Superhero();
        superhero.setFirstName(superheroRequest.firstName());
        superhero.setLastName(superheroRequest.lastName());
        superhero.setSuperheroName(superheroRequest.superheroName());
        Superhero newSuperhero = superheroRepository.save(superhero);
        return newSuperhero.getId();
    }

    // other methods intentionally left out
}
\end{lstlisting}


Now we need unit tests for the method \textit{createSuperhero}. There's one problem, we need a SuperheroRepository to thoroughly test the method.  The solution is to mock the database layer. Here,  mocking means create a dummy layer and no actual database operation will be executed. 

In Mockito we can mock methods in 2 different ways:

\begin{itemize}
\item Using when-then syntax e.g.: when(..).thenReturn() or when(..).thenAnswer(…)
\item Using do-when syntax e.g.: doReturn(..).when()
\end{itemize}

For mocked objects it is best practice to use when-then option as it provides return type checking and it is more readable.

For mocking void methods, there is no when-then option. We have to use do-when syntax.

\begin{lstlisting}[frame=single, language=java]
package be.pxl.superhero.service.impl;

import be.pxl.superhero.api.SuperheroDTO;
import be.pxl.superhero.api.SuperheroRequest;
import be.pxl.superhero.builder.SuperheroBuilder;
import be.pxl.superhero.domain.Superhero;
import be.pxl.superhero.repository.SuperheroRepository;
import jakarta.validation.ValidationException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class SuperheroServiceImplTest {

	private static final String SUPERHERO_NAME = "Superman";
	private static final String FIRST_NAME = "Clark";
	private static final String LAST_NAME = "Kent";
	private static final long SUPERHERO_ID = 115;

	@Mock
	private SuperheroRepository superheroRepository;
	@Mock
	private Superhero newSuperhero;

	@Captor
	private ArgumentCaptor<Superhero> superheroCaptor;

	@InjectMocks
	private SuperheroServiceImpl superheroService;

	private final Superhero superhero = SuperheroBuilder.aSuperhero()
			.withFirstName(FIRST_NAME)
			.withLastName(LAST_NAME)
			.withSuperheroName(SUPERHERO_NAME)
			.build();

	@Test
	public void throwsValidationExceptionWhenSuperheroNameIsNotUnique() {
		when(superheroRepository.findSuperheroBySuperheroName(SUPERHERO_NAME))
		    .thenReturn(Optional.of(superhero));
		SuperheroRequest request = new SuperheroRequest(FIRST_NAME, LAST_NAME, SUPERHERO_NAME);
		ValidationException validationException = assertThrows(ValidationException.class, 
		    () -> superheroService.createSuperhero(request));
		assertEquals("This superhero name is already taken.", validationException.getMessage());
	}

	@Test
	public void savesSuperheroWhenSuperheroNameIsUnique() {
		when(superheroRepository.findSuperheroBySuperheroName(SUPERHERO_NAME))
		    .thenReturn(Optional.empty());
		when(newSuperhero.getId())
		    .thenReturn(SUPERHERO_ID);
		when(superheroRepository.save(Mockito.any(Superhero.class)))
		    .thenReturn(newSuperhero);
		SuperheroRequest request = new SuperheroRequest(FIRST_NAME, LAST_NAME, SUPERHERO_NAME);
		Long newId = superheroService.createSuperhero(request);
		assertEquals(SUPERHERO_ID, newId);
		Mockito.verify(superheroRepository).save(superheroCaptor.capture());
		Superhero savedSuperhero = superheroCaptor.getValue();
		assertEquals(FIRST_NAME, savedSuperhero.getFirstName());
		assertEquals(LAST_NAME, savedSuperhero.getLastName());
		assertEquals(SUPERHERO_NAME, savedSuperhero.getSuperheroName());
	}

	@Test
	public void findAllSuperheroes() {
		Superhero hero1 = SuperheroBuilder.aSuperhero()
		                                  .withSuperheroName("Batman")
		                                  .build();
		Superhero hero2 = SuperheroBuilder.aSuperhero()
		                                  .withSuperheroName("Superman")
		                                  .build();
		when(superheroRepository.findAll()).thenReturn(Arrays.asList(hero1, hero2));
		List<SuperheroDTO> allSuperheroes = superheroService.findAllSuperheroes();
		assertThat(allSuperheroes.stream().map(SuperheroDTO::superheroName)
		                                  .collect(Collectors.toList()))
				.hasSize(2)
				.containsExactly("Batman", "Superman");
	}

}
\end{lstlisting}

All test classes that use Mockito, are annotated with @ExtendWith(MockitoExtension.class).  We want to create a dummy SuperheroRepository, therefore we create it with the annotation @Mock.
This dummy SuperheroRepsitory should be used by the SuperheroService under test.  We use the annotation @InjectMocks to use all the dummy classes in the SuperheroService instance.

The test throwsValidationExceptionWhenSuperheroNameIsNotUnique is a test for the scenario where the superhero is already saved in the database. Our dummy SuperheroRepository will return this existing superhero when he is retrieved by his superheroName.
During the test we call the method createSuperhero with test data but we expect the method to throw a ValidationException.  If the exception is not thrown, the test will fail. Finally, the error message of the exception is verified.

The test savesSuperheroWhenSuperheroNameIsUnique is a test for the scenario where the superhero doesn't exist yet.
The dummy SuperheroRepository will return an empty Optional.  While executing the test, the save method of the SuperheroRepository is called.  The result of this save method is used for creating the SuperheroDTO that is returned by the SuperheroService under test.
The save-method cannot return null, it would cause our test to end with a NullPointerException. Therefore, we make our dummy SuperheroRepository return something useful. We verify the return value of the method under test (createSuperhero). We verify the save() method is called with the expected argument.  This is accomplished with an argument captor. 

The third test is a test for the method findAllSuperheroes.  We test that the results retrieved from the dummy SuperheroRepository are mapped correctly to SuperheroDTOs.  This test uses AssertJ for the assertions. This is a useful library for writing readable assertions. 
 
\begin{oefening}
Add the class SuperheroServiceTest to your project and run (and debug!) the tests. 
Create a new test class with the name SuperheroServiceUpdateSuperheroTest.
Write unit tests for the method updateSuperhero in the class SuperheroServiceTest. 
\end{oefening}
 
 
 
 
 \section{Example of TDD}
 
 TODO::: https://learning.oreilly.com/course/master-java-unit/9781789346077/
 
 TESTING DOUBLES
 
 In general, it is a good thing to avoid tight coupling between components of the system. In line with
this rule, we want to make sure that the subscribers know as little as possible about the service, and vice
versa. To achieve this result, we can use a publish/subscribe design pattern7 which does exactly this: it
decouples publisher(s) from subscribers.
First, let us discuss some requirements for our class - RaceResultsService:
• It should allow clients to subscribe (which means they start receiving messages),
• It should allow subscribers to unsubscribe (which means they stop receiving messages),
• Every time a new message comes, it should be sent to all subscribers.
These simple requirements, along with some common sense, already furnish us with a lot of test cases.
In the ensuing sections we will be implementing the following:
• If the client is not subscribed, it should not receive any messages,
• If client is subscribed, it should receive each incoming message once (and only once),
• If multiple clients are subscribed, each of them should receive each incoming message,
• Consecutive subscribe requests issued by the same client will be ignored (nothing happens),
• If the client unsubscribes, then it should be the case that no more messages are sent to it.
We shall test RaceResultsService (the SUT) and make sure it sends messages to the right subscribers
(DOCs). At first glance, it seems like we must have at least three types to implement the discussed

from the book  practical testing (pdf)

Please enhance the Race Results example (see Section 5.4) with the following functionality:
• RaceResultsService should send messages with the results of different categories of race - e.g. horse
races, F1 races, boat-races, etc. Subscribers should be able to subscribe to selected categories. Make
sure they receive only messages related to the ones they have signed up for.
• Each message sent by RaceResultsService should be logged. Introduce a logging DOC, and make
sure that the date and text of each message is logged. Do not implement the logging mechanism:
concentrate on the interactions between the service and its collaborator.
• In the tests implemented so far, RaceResultsService sends only one message. This is unrealistic!
Enhance the tests to ensure that subscribers will receive any number of sent messages.
• What should happen if a client that is not subscribed tries to unsubscribe? Make up your mind about
it, write a test which verifies this behaviour, and make RaceResultsService behave accordingly.
 
 
 Example: Testing a Service Layer Method
Suppose you have a BookService that depends on a BookRepository. You want to test the findAllBooks() service method, which retrieves all books from the repository.

Step 1: Set Up Your Service and Repository

First, define your BookRepository and BookService interfaces:

java
Copy code
public interface BookRepository {
    List<Book> findAll();
}

@Service
public class BookService {
    private final BookRepository bookRepository;

    @Autowired
    public BookService(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

    public List<Book> findAllBooks() {
        return bookRepository.findAll();
    }
}
Step 2: Write the Test Class

Next, create a test class for BookService:

java
Copy code
@ExtendWith(SpringExtension.class)
public class BookServiceTest {

    @Mock
    private BookRepository bookRepository;

    @InjectMocks
    private BookService bookService;

    @Test
    public void testFindAllBooks() {
        // Arrange
        Book book1 = new Book("Book 1", "Author 1", 2019);
        Book book2 = new Book("Book 2", "Author 2", 2020);
        List<Book> mockBooks = Arrays.asList(book1, book2);
        Mockito.when(bookRepository.findAll()).thenReturn(mockBooks);

        // Act
        List<Book> result = bookService.findAllBooks();

        // Assert
        assertNotNull(result);
        assertEquals(2, result.size());
        Mockito.verify(bookRepository).findAll();
    }
}
In this example:

Arrange: Mock BookRepository's findAll() method to return a predefined list of books.
Act: Call findAllBooks() on BookService.
Assert: Check that the result is not null, contains the correct number of elements, and verify that findAll() was called on the repository.
Conclusion
Testing the service layer with Mockito in a Spring Boot application involves mocking dependencies to isolate the service layer's functionality. The example above demonstrates how to test a simple service method using Mockito annotations and methods. Remember, the key to effective testing is to isolate the component under test and simulate interactions with its dependencies using mocks.
 
 
 
