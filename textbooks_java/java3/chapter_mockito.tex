\chapter{Mockito}

\fcolorbox{black}[HTML]{E9F0E9}{\parbox{\textwidth}{%
\noindent \textbf{Learning goals}\\
The junior-colleague
\begin{enumerate}[nolistsep]
\item can describe the usage of mockito.
\item can implement unit tests with mockito.
\end{enumerate}}}

\section{Mocking with Mockito}

Mockito is a popular open source framework for mocking objects in software test.

\begin{lstlisting}
package be.pxl.superhero.service;

public class MyService {

    private final OtherService otherService;

    public MyService(OtherService otherService) {
        this.otherService = otherService;
    }

    public int doCalculation(int value) {
        return value * otherService.getValue();
    }
}
\end{lstlisting}

\begin{lstlisting}
package be.pxl.superhero.service;

public interface OtherService {

    int getValue();
}
\end{lstlisting}

When writing a unit test for the method doCalculation() we need an object of the class OtherService. We don't need an object of an actual implementation of the interface. We can just mock the OtherService-object and tell it what it should return when it's called.

\begin{lstlisting}
package be.pxl.superhero.service;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class MyServiceTest {

    @Mock
    private OtherService otherService;
    @InjectMocks
    private MyService myService;

    @Test
    public void doCalculationTest() {
        when(otherService.getValue()).thenReturn(5);
        assertEquals(500, myService.doCalculation(100));
    }
}
\end{lstlisting}

\section{Unit testing the service-layer methods}


We use Mockito when we test the Service-layer of an application. In this section we discuss more complex unit tests with Mockito.

The name of a superhero must be unique. To accomplish this, we add the unique constraint to our database column. 
However, it is good practice to implement this business rule in the service layer.
Database constraints are the last line of defence, not the only. 


\begin{lstlisting}[frame=single, language=java]
package be.pxl.superhero.service.impl;

import be.pxl.superhero.api.MissionDTO;
import be.pxl.superhero.api.SuperheroDTO;
import be.pxl.superhero.api.SuperheroDetailDTO;
import be.pxl.superhero.api.SuperheroRequest;
import be.pxl.superhero.domain.Mission;
import be.pxl.superhero.domain.Superhero;
import be.pxl.superhero.exception.ResourceNotFoundException;
import be.pxl.superhero.repository.MissionRepository;
import be.pxl.superhero.repository.SuperheroRepository;
import be.pxl.superhero.service.SuperheroService;
import jakarta.validation.ValidationException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
public class SuperheroServiceImpl implements SuperheroService {

    private final SuperheroRepository superheroRepository;
    private final MissionRepository missionRepository;

    public SuperheroServiceImpl(SuperheroRepository superheroRepository,
                                MissionRepository missionRepository) {
        this.superheroRepository = superheroRepository;
        this.missionRepository = missionRepository;
    }

    public Long createSuperhero(SuperheroRequest superheroRequest) {
        Optional<Superhero> existingSuperhero = 
            superheroRepository.findSuperheroBySuperheroName(superheroRequest.getSuperheroName());
        existingSuperhero.ifPresent(s -> {
            throw new ValidationException("This superhero name is already taken.");
        });
            
        Superhero superhero = new Superhero();
        superhero.setFirstName(superheroRequest.firstName());
        superhero.setLastName(superheroRequest.lastName());
        superhero.setSuperheroName(superheroRequest.superheroName());
        Superhero newSuperhero = superheroRepository.save(superhero);
        return newSuperhero.getId();
    }

    // other methods intentionally left out
}
\end{lstlisting}


Now we need unit tests for the method \textit{createSuperhero}. There's one problem, we need a SuperheroRepository to thoroughly test the method.  The solution is to mock the database layer. Here,  mocking means create a dummy layer and no actual database operation will be executed. 

In Mockito we can mock methods in 2 different ways:

\begin{itemize}
\item Using when-then syntax e.g.: when(..).thenReturn() or when(..).thenAnswer(â€¦)
\item Using do-when syntax e.g.: doReturn(..).when()
\end{itemize}

For mocked objects it is best practice to use when-then option as it provides return type checking and it is more readable.

For mocking void methods, there is no when-then option. We have to use do-when syntax.

\begin{lstlisting}[frame=single, language=java]
package be.pxl.superhero.service.impl;

import be.pxl.superhero.api.SuperheroDTO;
import be.pxl.superhero.api.SuperheroRequest;
import be.pxl.superhero.builder.SuperheroBuilder;
import be.pxl.superhero.domain.Superhero;
import be.pxl.superhero.repository.SuperheroRepository;
import jakarta.validation.ValidationException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class SuperheroServiceImplTest {

	private static final String SUPERHERO_NAME = "Superman";
	private static final String FIRST_NAME = "Clark";
	private static final String LAST_NAME = "Kent";
	private static final long SUPERHERO_ID = 115;

	@Mock
	private SuperheroRepository superheroRepository;
	@Mock
	private Superhero newSuperhero;

	@Captor
	private ArgumentCaptor<Superhero> superheroCaptor;

	@InjectMocks
	private SuperheroServiceImpl superheroService;

	private final Superhero superhero = SuperheroBuilder.aSuperhero()
			.withFirstName(FIRST_NAME)
			.withLastName(LAST_NAME)
			.withSuperheroName(SUPERHERO_NAME)
			.build();

	@Test
	public void throwsValidationExceptionWhenSuperheroNameIsNotUnique() {
		when(superheroRepository.findSuperheroBySuperheroName(SUPERHERO_NAME))
		    .thenReturn(Optional.of(superhero));
		SuperheroRequest request = new SuperheroRequest(FIRST_NAME, LAST_NAME, SUPERHERO_NAME);
		ValidationException validationException = assertThrows(ValidationException.class, 
		    () -> superheroService.createSuperhero(request));
		assertEquals("This superhero name is already taken.", validationException.getMessage());
	}

	@Test
	public void savesSuperheroWhenSuperheroNameIsUnique() {
		when(superheroRepository.findSuperheroBySuperheroName(SUPERHERO_NAME))
		    .thenReturn(Optional.empty());
		when(newSuperhero.getId())
		    .thenReturn(SUPERHERO_ID);
		when(superheroRepository.save(Mockito.any(Superhero.class)))
		    .thenReturn(newSuperhero);
		SuperheroRequest request = new SuperheroRequest(FIRST_NAME, LAST_NAME, SUPERHERO_NAME);
		Long newId = superheroService.createSuperhero(request);
		assertEquals(SUPERHERO_ID, newId);
		Mockito.verify(superheroRepository).save(superheroCaptor.capture());
		Superhero savedSuperhero = superheroCaptor.getValue();
		assertEquals(FIRST_NAME, savedSuperhero.getFirstName());
		assertEquals(LAST_NAME, savedSuperhero.getLastName());
		assertEquals(SUPERHERO_NAME, savedSuperhero.getSuperheroName());
	}

	@Test
	public void findAllSuperheroes() {
		Superhero hero1 = SuperheroBuilder.aSuperhero()
		                                  .withSuperheroName("Batman")
		                                  .build();
		Superhero hero2 = SuperheroBuilder.aSuperhero()
		                                  .withSuperheroName("Superman")
		                                  .build();
		when(superheroRepository.findAll()).thenReturn(Arrays.asList(hero1, hero2));
		List<SuperheroDTO> allSuperheroes = superheroService.findAllSuperheroes();
		assertThat(allSuperheroes.stream().map(SuperheroDTO::superheroName)
		                                  .collect(Collectors.toList()))
				.hasSize(2)
				.containsExactly("Batman", "Superman");
	}

}
\end{lstlisting}

All test classes that use Mockito, are annotated with @ExtendWith(MockitoExtension.class).  We want to create a dummy SuperheroRepository, therefore we create it with the annotation @Mock.
This dummy SuperheroRepsitory should be used by the SuperheroService under test.  We use the annotation @InjectMocks to use all the dummy classes in the SuperheroService instance.

The test throwsValidationExceptionWhenSuperheroNameIsNotUnique is a test for the scenario where the superhero is already saved in the database. Our dummy SuperheroRepository will return this existing superhero when he is retrieved by his superheroName.
During the test we call the method createSuperhero with test data but we expect the method to throw a ValidationException.  If the exception is not thrown, the test will fail. Finally, the error message of the exception is verified.

The test savesSuperheroWhenSuperheroNameIsUnique is a test for the scenario where the superhero doesn't exist yet.
The dummy SuperheroRepository will return an empty Optional.  While executing the test, the save method of the SuperheroRepository is called.  The result of this save method is used for creating the SuperheroDTO that is returned by the SuperheroService under test.
The save-method cannot return null, it would cause our test to end with a NullPointerException. Therefore, we make our dummy SuperheroRepository return something useful. We verify the return value of the method under test (createSuperhero). We verify the save() method is called with the expected argument.  This is accomplished with an argument captor. 

The third test is a test for the method findAllSuperheroes.  We test that the results retrieved from the dummy SuperheroRepository are mapped correctly to SuperheroDTOs.  This test uses AssertJ for the assertions. This is a useful library for writing readable assertions. 
 
\begin{oefening}
Add the class SuperheroServiceTest to your project and run (and debug!) the tests. 
Create a new test class with the name SuperheroServiceUpdateSuperheroTest.
Write unit tests for the method updateSuperhero in the class SuperheroServiceTest. 
\end{oefening}
 
 
 
 
 
 
