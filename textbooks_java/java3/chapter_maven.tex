\chapter{Maven}
\label{chap:maven}

\fcolorbox{black}[HTML]{E9F0E9}{\parbox{\textwidth}{%
\noindent \textbf{Learning goals}\\
The junior-colleague
\begin{enumerate}[nolistsep]
\item can explain what Maven is.
\item can describe the 3 build lifecycles of Maven.
\item can explain that each build lifecycle is made up of phases.
\item can explain that each build phase is made up of plugin goals.
\item can identify the project coordinates.
\item can describe the Maven Standard Directory Layout.
\item can explain what a dependency is.
\item can describe the different dependency scopes.
\item can explain what a transitive dependency is.
\item can explain what a dependency tree is.
\item can execute maven commands from CLI.
\item can manage dependencies with Maven.
\item can create a REST endpoint that provides an image or a file.
\item can run code analysis on a Spring boot project (with SonarQube).
\item can fix bugs, vulnerabilities and code smells detected by SonarQube.
\end{enumerate}}}

\section{What is Maven?}

Maven is a tool that can be used for building and managing Java-based projects.
Every Java project requires certain dependencies, which are automatically downloaded when using Maven.

The main objectives of using Maven for developers are:
\begin{itemize}
\item Making the build process easy
\item Providing a uniform build system
\item Providing information about project quality (for example unit test reports)
\item Encouraging better development practices
\end{itemize}

Maven is much more than a build tool.  Maven offers support for automatic source generation,  compiling the source code and test sources, packaging final product(s) for different environments, running health checks and reporting.  Continuous builds, integration, and testing can be easily handled by using Maven. A tool commonly used for creating CI/CD pipelines (continuous integration and continuous delivery) is Jenkins.  Jenkins cannot replace Maven or vice-versa. Jenkins can use Maven as its build tool.  
When Jenkins deploys artifacts to remote repositories, they are usually Maven repositories. 

According to snyk's 2021 JVM ecosystem report \footnote{\url{https://snyk.io/jvm-ecosystem-report-2021/}} Maven is most popular build tool for the Java ecosystem.

\section{Installation and Configuration}

IntelliJ IDEA has in-built support for Maven.  However we want to make Maven available in the command-line interface. Therefore we need to install Maven. 

 \fcolorbox{black}[HTML]{ADD8E6}{\parbox{\textwidth}{%
\noindent \textbf{Maven download and documentation pages:}\\
Download page: \url{https://maven.apache.org/download.cgi}\\
Installation instructions: \url{https://maven.apache.org/install.html}
}}

Confirm that Maven is installed correctly by executing \fbox{\strut \$mvn -v} in a terminal window. 

\begin{lstlisting}[language=bash, frame=single]
$ mvn -v
Apache Maven 3.8.2 (ea98e05a04480131370aa0c110b8c54cf726c06f)
Maven home: /usr/local/Cellar/maven/3.8.2/libexec
Java version: 17.0.1, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk-17.0.1.jdk/Contents/Home
Default locale: nl_BE, platform encoding: UTF-8
OS name: "mac os x", version: "11.5.2", arch: "x86_64", family: "mac"
\end{lstlisting}


\section{Maven Standard Directory Layout}

When you create a new Maven project, a directory which name matches the artifactId is generated. This directory is known as the project’s base directory. 
Every Maven project has a file named \textbf{pom.xml} which is known as the \textbf{Project Object Model} (POM). This file describes the project, configures plugins, and declares dependencies.
The project’s source code and resources are placed in the folder \textbf{src/main}.
The project’s unit tests are located in \textbf{src/test}.
The target folder is the Maven default output folder. You can delete all the target's folder content with the \fbox{\strut \$mvn clean} command.


\section{Maven architecture}

\includegraphics[width=\textwidth]{./images/chapter3/maven-architecture} 

Central repository is provided by the Maven community. This Central repository contains a large number of common libraries.  Whenever you specify a dependency in pom.xml,  Maven will look for it in the local repository first. If the necessary dependency  isn't included in the local repository, Maven will download it from the Central repository and copy it to your local repository.  Remote repository is a place where developers (or Jenkins) can copy the final packages, so other developer can use these final packages as a dependency in their projects.

Acces to internet is recommended when using Maven, however it is possible to work offline if all dependencies are available in your local repository.


\section{Maven built-in life cycles}

There are three built-in life cycles defined in Maven.  The \textit{default} build life cycle is the main build life cycle.

\begin{tabularx}{\textwidth}{ |l|X|l| } 
\hline
clean & handles the cleanup of directories and files generated during the build process & mvn clean \\ 
default & handles the build and distribution of the project & mvn [plugin:goal]* [phase]* \\ 
site & create project documentation & mvn site \\ 
\hline
\end{tabularx}

To run a specific goal, without executing the entire phase (and the preceding phases) the command \fbox{\strut \$mvn [plugin:goal]} can be used.  Phases on the other hand are executed in a specific order and all the preceding phases are executed as well!

\section{A Build Lifecycle is Made Up Of Phases}

Each life cycle consists of a sequence of phases. The default build lifecycle consists of 23 phases. In the image below the 8 main phases are included. On the other hand, clean lifecycle consists of 3 phases, while the site lifecycle is made up of 4 phases.

\includegraphics[width=\textwidth]{./images/chapter3/maven-lifecycles} 

Each phase is responsible for a specific task. Here are the 8 most important phases in the default build lifecycle.

\begin{tabularx}{\textwidth}{ |l|X| } 
 \hline
validate & check if all information necessary for the build is available \\
compile & compile the source code \\
test & run unit tests \\
package & package compiled source code into the distributable format, (jar, war, …)\\
integration-test & process and deploy the package if needed to run integration tests \\
verify & run any checks on results of integration tests to ensure quality criteria are met\\
install & install the package to a local repository\\
deploy & copy the package to the remote repository\\
 \hline
\end{tabularx}

\section{Plugins and Goals}

Maven is actually a plugin execution framework. Every task executed by Maven is actually done by a \textbf{goal}, where goals are grouped together in \textbf{plugins}.  When we run a phase, all the goals bound to the phase are executed in order.

\includegraphics[width=\textwidth]{./images/chapter3/maven_goals} 

Several phases of the default built-in lifecycles have goals bounded to them.  Due to this default configuration you're able to build a Java project without extra configuration.

\includegraphics[width=\textwidth]{./images/chapter3/maven-lifecycle-binding} 

The compile goal from the compiler plugin is bound to the compile phase and is responsible for compiling the source code. The test goal from the surefire plugin is bound to the test phase and is reponsible for running the unit tests.

You can generate an overview of all the phases and the specific goals bounded to these phases by running the command \fbox{\strut \$mvn help:describe -Dcmd=PHASENAME}

\begin{lstlisting}[language=bash, frame=single]
$ cd superhero-backend/
$ mvn help:describe -Dcmd=compile
[INFO] Scanning for projects...
[INFO] 
[INFO] ----------------------< be.pxl:superhero-backend >----------------------
[INFO] Building superhero-backend 0.0.1-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-help-plugin:3.3.0:describe (default-cli) @ superhero-backend ---
[INFO] 'compile' is a phase corresponding to this plugin:
org.apache.maven.plugins:maven-compiler-plugin:3.1:compile

It is a part of the lifecycle for the POM packaging 'jar'. This lifecycle includes the following phases:
* validate: Not defined
* initialize: Not defined
* generate-sources: Not defined
* process-sources: Not defined
* generate-resources: Not defined
* process-resources: org.apache.maven.plugins:maven-resources-plugin:2.6:resources
* compile: org.apache.maven.plugins:maven-compiler-plugin:3.1:compile
* process-classes: Not defined
* generate-test-sources: Not defined
* process-test-sources: Not defined
* generate-test-resources: Not defined
* process-test-resources: org.apache.maven.plugins:maven-resources-plugin:2.6:testResources
* test-compile: org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile
* process-test-classes: Not defined
* test: org.apache.maven.plugins:maven-surefire-plugin:2.12.4:test
* prepare-package: Not defined
* package: org.apache.maven.plugins:maven-jar-plugin:2.4:jar
* pre-integration-test: Not defined
* integration-test: Not defined
* post-integration-test: Not defined
* verify: Not defined
* install: org.apache.maven.plugins:maven-install-plugin:2.4:install
* deploy: org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  0.896 s
[INFO] Finished at: 2023-02-26T17:19:03+01:00
[INFO] ------------------------------------------------------------------------
\end{lstlisting}


There are two types of plugins:
\begin{itemize}
\item \textbf{Build plugins}: The goals of build plugins are executed during the build process.  If you want to execute additional goals during a phase of the build process, you need to configure the goal in the \xml{build} element of the pom.xml.
\item \textbf{Reporting plugins}: Reporting plugins are executed during the site generation process. These plugins are configured in the \xml{reporting} element of the pom.xml.
\end{itemize}

\section{Dependencies and scopes}

A repository in Maven stores artifacts and dependencies of varying types. There are exactly two types of repositories: local and remote.

The \textbf{local repository} is a directory on the machine that runs Maven.  By default  Maven's local repository is located in the folder \${user.home}/.m2/repository. As you can see, this is a hidden folder.  If you're unable to find the default .m2 folder, you can run the following command:
\fbox{\strut \$mvn help:evaluate -Dexpression=settings.localRepository}

\textbf{Remote repositories} refer to any other type of repository, accessed by a variety of protocols such as file:// and https://. 

\begin{oefening}
Locate and open the folder containing your local repository. 
\end{oefening}

If you're looking for a dependency to add, you can use the Maven Central Repository Search \footnote{\url{https://search.maven.org}}. 

There are two types of dependencies in Maven: direct and transitive. \textbf{Direct dependencies} are the dependencies that are defined in the pom.xml under the \xml{dependencies} section.  \textbf{Transitive dependencies} are dependencies of your direct dependencies.  This means if your project needs dependency A and A depends on B, then your project needs both A and B. However, for Maven it suffices to add dependency A in the pom.xml. The transitive dependency B is included automatically.

You can generate the dependency tree with direct and transitive dependencies by running
 \fbox{\strut \$mvn dependency:tree}.

Sometimes, transitivity brings a very serious problem causing version mismatch issues at runtime.
when multiple versions of the same artifact are encountered, Maven picks the ``nearest definition''. It uses the version of the closest dependency in the dependency tree.

\begin{verbatim}
 A
 \-- B
    \-- C
       \-- D 2.0
 \-- E
    \-- D 1.0
\end{verbatim}

D 1.0 will be used when building project A because the path from A to D through E is shorter. You can explicitly add a dependency to D 2.0 in A to force the use of D 2.0.

\begin{verbatim}
A
 \-- B
    \-- C
       \-- D 2.0
 \-- E
    \-- D 1.0
 \-- D 2.0
 \end{verbatim}

There are 6 dependency scopes which are used to limit the transitivity of dependencies and determine when a dependency should be included in the classpath.

\begin{tabularx}{\textwidth}{ |l|X| } 
 \hline
 compile & 
This is the default scope. Depencencies with this scope are available on the classpath for all the build tasks.\\
provided &
Dependencies that are provided at runtime by JDK or a container. The provided dependencies are available at compile-time and in the test classpath.\\
runtime &
The dependencies with this scope are only required at runtime. They are not needed at compile-time and in the test classpath.\\
test &
These dependencies are only needed for executing tests.\\
system &
Similar to provided but specific jar is provided.\\ 
import &
All dependencies listed in another pom are included.\\
\hline
\end{tabularx}

\section{Exercise}

In the exercise we implement a REST endpoint that returns a PDF file.

\begin{lstlisting}
@GetMapping(value = "/pdfreport", produces = MediaType.APPLICATION_PDF_VALUE)
public @ResponseBody byte[] createPdfReport() {

    ByteArrayInputStream bis = GeneratePdfReport.createReport();

	return bis.readAllBytes();
}
\end{lstlisting}

In the example above we assume to have a helper class GeneratePdfReport that has a method returning a ByteArrayInputStream with the data of your PDF file. We use the @ResponseBody annotation on the controller method to indicate that the object returned by the method should be marshaled directly to the HTTP response body.

For creating PDF files in Java, we'll use itextpdf: \url{https://mvnrepository.com/artifact/com.itextpdf/itextpdf}.

For creating the qr code we will use the ZXing (`Zebra Crossing') API, a popular API for QR code processing in Java. You'll need to include 2 artifacts to be able to generate QR codes.

\begin{lstlisting}
<dependency>
	<groupId>com.google.zxing</groupId>
	<artifactId>core</artifactId>
	<version>3.4.0</version>
</dependency>
<dependency>
	<groupId>com.google.zxing</groupId>
	<artifactId>javase</artifactId>
	<version>3.4.0</version>
</dependency>
\end{lstlisting}

Here is the full code for filling the name and QR code in the PDF template.

\begin{lstlisting}
package be.pxl.superhero.service.impl;

import be.pxl.superhero.api.SuperheroDTO;
import be.pxl.superhero.commons.Cipher;
import com.google.zxing.BarcodeFormat;
import com.google.zxing.WriterException;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Element;
import com.itextpdf.text.Image;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.pdf.ColumnText;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfStamper;
import org.springframework.stereotype.Component;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.nio.file.Paths;

@Component
public class SuperheroIdCardGenerator {

    public ByteArrayInputStream superheroIdCard(SuperheroDTO superhero) {

        ByteArrayOutputStream out = new ByteArrayOutputStream();

        try {
            Path path = 
                Paths.get(ClassLoader.getSystemResource("superheroidcard.pdf").toURI());
            PdfReader pdfReader = new PdfReader(path.toUri().toURL());
            PdfStamper pdfStamper = new PdfStamper(pdfReader, out);
            PdfContentByte canvas = pdfStamper.getOverContent(1);
            ColumnText.showTextAligned(canvas, Element.ALIGN_LEFT, new Phrase(superhero.firstName() + " " + superhero.lastName()), 200, 620, 0);
            ColumnText.showTextAligned(canvas, Element.ALIGN_LEFT, new Phrase(superhero.superheroName()), 200, 550, 0);
            byte[] qrCodeImage = getQRCodeImage(Cipher.skipALetter(superhero.superheroName()), 130, 130);
            Image qrCode = Image.getInstance(qrCodeImage);
            qrCode.setAbsolutePosition(190, 360);
            canvas.addImage(qrCode);
            pdfStamper.close();
            pdfReader.close();
        } catch (DocumentException | URISyntaxException | IOException | WriterException ex) {
            // TODO: add logging - see next chapter
            throw new PdfCreationException(ex);
        }
        return new ByteArrayInputStream(out.toByteArray());
    }

    public static byte[] getQRCodeImage(String text, int width, int height) throws WriterException, IOException {
        QRCodeWriter qrCodeWriter = new QRCodeWriter();
        BitMatrix bitMatrix = qrCodeWriter.encode(text, BarcodeFormat.QR_CODE, width, height);

        ByteArrayOutputStream pngOutputStream = new ByteArrayOutputStream();

        MatrixToImageWriter.writeToStream(bitMatrix, "PNG", pngOutputStream);
        return pngOutputStream.toByteArray();
    }
}
\end{lstlisting}

The PdfReader first opens the PDF template file. The PdfStamper is used for adding the full name, the alias and the
QR code (as an image) to the template. The newly generated PDF is returned as a ByteArrayInputStream.

\begin{oefening}

All superheroes need an id card. Your job as a developer is to create a REST endpoint where we can download a pdf with the id card.

\includegraphics[width=5cm]{./images/chapter3/superhero_id_card.png}

The pdf template can be found in blackboard. 

$\square$ Download the pdf template and add it to the resources directory of your superhero-backend project.

\vspace{5mm}

We will include the full name, the superhero name and a unique QR code in the template.
The generated pdf will be available at the endpoint:
\url{http://localhost:<port>/api/superheroes/<superheroId>/idcard}

The QR code will contain the scrambled alias of a superhero. 

\vspace{5mm}

$\square$ Create the utility class Cipher with a static method skipALetter which takes a String as a parameter and returns the scrambled String. To encrypt a sentence you divide each word into half. If a word has an odd number of letters, the first group of letters contains one letter extra. Take the first letter of the first group, followed by the first letter of the second group. Then, write the second letter of the first group and the second letter of the second group, and so on, until all the words are encrypted. For example, if your sentence is `SECRET CODES', it will be encrypted as `SREECT CEOSD'.

Write unit tests to test your implementation. 
\begin{itemize}
\item unit test for one word with even length
\item unit test for one word with odd length
\item unit test for a sentence with multiple words with odd and even length
\item unit test for an empty string (should return an empty string)
\end{itemize}

\vspace{5mm}

$\square$ Implement the REST endpoint for retrieving a superhero's id card.  
\end{oefening}

\section{Code quality with SonarQube}

We would like to deliver high quality Java code. SonarQube is a Java analyzer that checks the quality of our code and detects code smells.

\begin{oefening}

Create a docker container with SonarQube. Run the following command in a terminal window:

\fbox{\strut docker run -d -{}-name sonarqube -p 9000:9000 -p 9092:9092 sonarqube}

Open \url{http://localhost:9000} in a browser. You can login with the default username `admin' and password `admin'. Next you have to update the default password (you have to choose a new password!).

\vspace{5mm}

Create a new SonarQube project for the superhero-backend application. Click on the button `Manually', fill out the project details and choose to analyze your project locally. A token will be generated.

\includegraphics{./images/chapter3/sonarqube_create_project.png}

Now we can update the pom.xml file of our superhero-backend to run the code analysis.

First we need a sonar profile to provide the url, project key and token.

\begin{lstlisting}
<profiles>
	<profile>
		<id>sonar</id>
		<activation>
			<activeByDefault>true</activeByDefault>
		</activation>
		<properties>
			<sonar.host.url>http://localhost:9000</sonar.host.url>
			<sonar.projectKey>superhero-backend</sonar.projectKey>
			<sonar.login>sqp_6319ae2795ccdc24baa3a994962a8bbaa0b0cc16</sonar.login>
		</properties>
	</profile>
</profiles>
\end{lstlisting}

Run the following maven command to perform the code analysis:
\fbox{\strut \$mvn clean verify sonar:sonar}

\vspace{5mm}

Open the SonarQube dashboard \url{http://localhost:9000/dashboard?id=superhero-backend} to get an overview of possible bugs, vulnerabilities and code smells.
You can get a more in-depth explanation of the code quality rules including examples at \url{https://rules.sonarsource.com/java}. Namely, \url{https://rules.sonarsource.com/java/RSPEC-5786} is an interesting code smell to look at.

\vspace{5mm}

\includegraphics[width=\textwidth]{./images/chapter3/sonarqube.png}

When you look at the dashboard, you'll see the code coverage is always 0.0\%. JaCoCo is needed to generate an extra report to display the code coverage.

First add the property jacoco.version in the pom.xml file:

\begin{lstlisting}
<properties>
	<java.version>17</java.version>
	<jacoco.version>0.8.7</jacoco.version>
</properties>
\end{lstlisting}

Next, add the JaCoCo maven plugin to your project.

\begin{lstlisting}
<build>
	<plugins>
		<plugin>
			<groupId>org.jacoco</groupId>
			<artifactId>jacoco-maven-plugin</artifactId>
			<version>${jacoco.version}</version>
			<executions>
				<execution>
					<id>prepare-agent</id>
					<goals>
						<goal>prepare-agent</goal>
					</goals>
				</execution>
				<execution>
					<id>report</id>
					<phase>test</phase>
					<goals>
						<goal>report</goal>
					</goals>
				</execution>
			</executions>
		</plugin>
	</plugins>
	<pluginManagement>
		<plugins>
			...
		</plugins>
	</pluginManagement>
</build>
\end{lstlisting}

During the test phase JaCoCo will generate a report and save it in the directory target/site/jacoco/jacoco.xml. SonarQube will automatically check this location and the report will be picked up.
First remove the empty, automatically created Spring Boot test from your test folder.
Run the Maven command again and check your code coverage.

\end{oefening}

\includegraphics[width=\textwidth]{./images/chapter3/sonarqube-report.png}

\section{Maven commands}

Here is a brief list of usefull Maven commands.

\begin{tabularx}{\textwidth}{ |l|X| } 
\hline
\textbf{Maven Command}	& \textbf{Description} \\
\hline
mvn -v	& Prints out the version of Maven you are running.\\ 
mvn --version & Same as mvn -v\\
mvn clean	& Clears the target directory into which Maven normally builds your project.\\
mvn package & Builds the project and packages the resulting JAR file into the target directory.\\
mvn package -DskipTests &	Builds the project and packages the resulting JAR file into the target directory without running the unit tests during the build. You can also use -Dmaven.test.skip=true\\
mvn clean package &	Clears the target directory,  builds the project and packages the resulting JAR file into the target directory.\\
mvn install & Builds the project described by your Maven POM file and installs the resulting artifact (JAR) into your local Maven repository.\\
mvn -X package & Prints the maven version and runs the build in the debug mode. \\
mvn -o package & This command is used to run the maven build in the offline mode.\\
mvn -help & Prints the Maven usage and all the available options.\\
mvn dependency:tree & Generates the dependency tree of the Maven project.\\
\hline
\end{tabularx}

